---
title: "scATAC_reassignment"
output: 
  html_document:
    df_print: paged
  html_notebook:
editor_options:
  chunk_output_type: inline
---

--> focus on motifs from chondrocytes trajectory
--> do the correlation analysis for all motifs above
--> the logic of keep 1 motif per TF annotation: chondrocytes > mesenchyme on chondrocytes trajectory > other mesenchyme > non-mesenchyme

```{r setup, message=FALSE, warning=FALSE, echo=FALSE}
library(Signac);library(Seurat)
library(ggplot2);library(limma)
library(pheatmap);library(viridis);library(RColorBrewer)
library(slingshot)

set.seed(1234)
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
gene.info=read.table("/scicore/home/tschoppp/GROUP/lab/skeletalconvergence/fromMenghan/scRNA/ensembl97_geneinfo.txt",
                     sep="\t",header = TRUE,row.names = 1,stringsAsFactors = FALSE)
gene.info[gene.info$genename=="","genename"]=rownames(gene.info[gene.info$genename=="",])
gene.info$genename=toupper(gene.info$genename)

#as AnimalTFDB3 include most of the TFs, so use this list (result from motif_changeFormat.Rmd: 549/597=0.92)
tfs=read.table("~/references/Gallus_gallus_TF_AnimalTFDB3_edited.txt",sep="\t",header = TRUE,stringsAsFactors = FALSE)
#length(tfs$Ensembl[tfs$Ensembl %in% rownames(gene.info)]) --> 1079/1268,tfs$origin:animalTFDB3.chicken.notIn200819gtf
mid2name=read.table("~/references/motifs/motif_id2name.txt",sep = "\t",header = T,stringsAsFactors = F)
rownames(mid2name)=mid2name$motif_id

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
#keep only one motif for each TF
#--> if exist, use the one with lowest Homer P-value from this origin chondrocytes;
#--> if not, use the one from pseudotime trajectory;
#--> if not, use the one from rest mesenchyme of same origin;
#--> if not, use the one from same origin, other cell type;

# because if the motif is in this origin both mesenchymal and non-mesenchymal populations, but the homer Pvalue in non-mesenchymal population is lower, than will be defined as non-mesenchymal motif. Don't want to miss those also play a role in mesenchymal population.

# function
get2tf=function(tfnames=mf2tfnames.all$overall,
                used.origin="L",used.cls="sub|Mschym",
                used.ptime=ptime.cls[["limb"]]){
  tf.uni=unique(tfnames$tfname)
  used.tf=data.frame(tfname=tf.uni, mfnew="",id="",cls="")
  
  for(i in 1:nrow(used.tf)){
    tmp.tf=used.tf$tfname[i]
    tmp.candidates=tfnames[tfnames$tfname==tmp.tf,]
    tmp.chondrocytes.origin=tmp.candidates[grepl("-chondrocytes",tmp.candidates$clsname) & tmp.candidates$origin==used.origin,]
    tmp.ptime.origin=tmp.candidates[grepl(used.ptime,tmp.candidates$clsname) & tmp.candidates$origin==used.origin,]
    tmp.testcls.origin=tmp.candidates[grepl(used.cls,tmp.candidates$cls) & tmp.candidates$origin==used.origin,]
    tmp.origin=tmp.candidates[tmp.candidates$origin==used.origin,]
    tmp.any=tmp.candidates
    #use the one with lowest Homer P-value from this origin chondrocytes
    if(nrow(tmp.chondrocytes.origin)>=1){
      tmp.used=tmp.chondrocytes.origin
    }else if(nrow(tmp.ptime.origin)>=1){ #if not, use the one from pseudotime trajectory
      tmp.used=tmp.ptime.origin
    }else if(nrow(tmp.testcls.origin)>=1){ #if not, use the one from rest mesenchyme of same origin
      tmp.used=tmp.testcls.origin
    }else if(nrow(tmp.origin)>=1){ #if not, use the one from same origin, other cell type
      tmp.used=tmp.origin
    }
    tmp.used=tmp.used[order(tmp.used$homerPval),]
    used.tf$mfnew[i]=tmp.used$mfnew[1]
    used.tf$id[i]=tmp.used$motifid[1]
    used.tf$cls[i]=tmp.used$cls[1]
  }
  used.tf=used.tf[used.tf$id!="",]
  return(used.tf)
  
}


# the logic for chosenTF:
# res$trend[i] %in% c("enhancer","unknown"
#--> original TF << matched TF: res$`originalTF.cor`[i]<=0.1 & res$`matchedTF.cor`[i]>0.1 & res$`matchedTF.pval`[i]<=0.05, change
#--> #original TF is not significant, while matched TF is: res$`originalTF.cor`[i]>0.1 & res$`originalTF.pval`[i]>0.05 & res$`matchedTF.cor`[i]>0.1 & res$`matchedTF.padj`[i]<=0.05, change
#--> others, remain
#similar logic for repressor

getChosenTF=function(res=res){
  for(i in 1:nrow(res)){
    
    if(res$trend[i] %in% c("enhancer","unknown")){
      #original TF << matched TF
      if(res$`originalTF.cor`[i]<=0.1 & res$`matchedTF.cor`[i]>0.1 & res$`matchedTF.pval`[i]<=0.05){
        res$chosenTF[i]=res$matchedTF[i]
        res$`chosenTF.padj`[i]=res$`matchedTF.padj`[i]
        res$`chosenTF.pval`[i]=res$`matchedTF.pval`[i]
      }else if(res$`originalTF.cor`[i]>0.1 & res$`originalTF.pval`[i]>0.05 & res$`matchedTF.cor`[i]>0.1 & res$`matchedTF.padj`[i]<=0.05){
        #original TF is not significant, while matched TF is
        res$chosenTF[i]=res$matchedTF[i]
        res$`chosenTF.padj`[i]=res$`matchedTF.padj`[i]
        res$`chosenTF.pval`[i]=res$`matchedTF.pval`[i]
      }else{
        res$consist[i]=1
        res$chosenTF[i]=res$originalTF[i]
        res$`chosenTF.padj`[i]=res$`originalTF.padj`[i]
        res$`chosenTF.pval`[i]=res$`originalTF.pval`[i]
      }
    }else{ #repressor
      #original TF << matched TF
      if(res$`originalTF.cor`[i]>=(-0.1) & res$`matchedTF.cor`[i]<(-0.1) & res$`matchedTF.pval`[i]<=0.05){
        res$chosenTF[i]=res$matchedTF[i]
        res$`chosenTF.padj`[i]=res$`matchedTF.padj`[i]
        res$`chosenTF.pval`[i]=res$`matchedTF.pval`[i]
      }else if(res$`originalTF.cor`[i]<(-0.1) & res$`originalTF.pval`[i]>0.05 & res$`matchedTF.cor`[i]<(-0.1) & res$`matchedTF.padj`[i]<=0.05){
        #original TF is not significant, while matched TF is
        res$chosenTF[i]=res$matchedTF[i]
        res$`chosenTF.padj`[i]=res$`matchedTF.padj`[i]
        res$`chosenTF.pval`[i]=res$`matchedTF.pval`[i]
      }else{
        res$consist[i]=1
        res$chosenTF[i]=res$originalTF[i]
        res$`chosenTF.padj`[i]=res$`originalTF.padj`[i]
        res$`chosenTF.pval`[i]=res$`originalTF.pval`[i]
      }
    }
    
  }
  return(res)
}


```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
mf2tfnames.all=readRDS(paste0("~/scATAC/motifenrich/all_denovoMotifs_mf2tfnames.rds"))
tfnames=mf2tfnames.all$overall
#uni=tfnames[!duplicated(tfnames$tfname),"tfname"]
#length(uni[uni %in% tfs$Symbol]) --> 210/258, 48 are not in tfs$Symbol, most of them like this:"LIN28A|LIN28B"

ptime.cls=list()
ptime.cls[["limb"]]=paste(c("WNT5AMesenchyme","chondrocytes","lateChondrocytes","amb_mesenchymeORnsConnectiveTissue"),collapse = "|")
ptime.cls[["nasal"]]=paste(c("neuralcrestDerivedMesenchyme","eyeConnectiveTissue","chondrocytes"),collapse = "|")
ptime.cls[["somite"]]=paste(c("somite2","somite1","chondrocytes"),collapse = "|")

ptime.clsid=list()
ptime.clsid[["limb"]]=c("clssub1","clssub5","clssub6","clssub3")
ptime.clsid[["nasal"]]=c("clssub3","clssub5","clssub6")
ptime.clsid[["somite"]]=c("clssub5","clssub1","clssub4")

my.origins=c("limb","somite","nasal")
my.files=paste0("~/scRNA/clustering/subset_",my.origins,".rds")
my.pfiles=paste0("~/scRNA/pseudotime/ptime_",my.origins,"_slingshot.rds")
my.mfiles=paste0("~/scRNA/clustering/meta_",my.origins,".rds")
cid=c("curve1","curve2","curve4")
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
## compare not only TF with same name, but other paralogs
# data from ensembl v97 biomart: http://jul2019.archive.ensembl.org/biomart/martview/e3186f08cf1276a63be847f49e9d5c96
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4964396/
paralogs=read.table("~/references/ensembl_chickenParalog_v97.txt",sep="\t",header = T)
paralogs$Gene.name=toupper(paralogs$Gene.name)
paralogs$Chicken.paralogue.associated.gene.name=toupper(paralogs$Chicken.paralogue.associated.gene.name)
paralogs[paralogs$Chicken.paralogue.associated.gene.name=="","Chicken.paralogue.associated.gene.name"]=paralogs[paralogs$Chicken.paralogue.associated.gene.name=="","Chicken.paralogue.gene.stable.ID"]
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
##################
## generate a set of TF: based on Gallus_gallus_TF_AnimalTFDB3_edited.txt & motif_id2name.txt
tf.set1=tfs$Ensembl

tmp=mid2name$motif_name
tmp=unique(tmp[tmp!="notExist"]);length(tmp)
tmp.extra=NULL
for(i in 1:length(tmp)){
  if(grepl("\\|",tmp[i])){
    tmp.mf=gsub("\\|",",",tmp[i])
    tmp.mf=unlist(strsplit(tmp.mf,","))
    tmp.extra=c(tmp.extra,tmp.mf)
  }
}
tmp=toupper(c(tmp,tmp.extra))
tmp=unique(tmp[!grepl("\\|",tmp)]);length(tmp)
tf.set2=rownames(gene.info[gene.info$genename %in% tmp,]);length(tf.set2)

tf.set=c(tf.set1,tf.set2)
tf.set=unique(tf.set);length(tf.set)
length(tf.set1);length(tf.set1[tf.set1 %in% rownames(gene.info)])
#tf.set1 is the reason where some genes are missed
length(tf.set2);length(tf.set2[tf.set2 %in% rownames(gene.info)])
length(tf.set[tf.set %in% rownames(gene.info)])

#convert to ensembl id
tf.set.id=tf.set[tf.set %in% rownames(gene.info)];length(tf.set.id)
tf.set.name=gene.info[tf.set.id,"genename"];length(tf.set.name)
print(paste0("the number of genes annotated as TFs: ",length(tf.set.id)))
```

## limb

```{r, message=FALSE, warning=FALSE, echo=TRUE}
samples="limb"
ph=readRDS(paste0("~/scATAC/motifReassign/ptbinMatrix_",samples,".rds"))
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
# keep only the ptbin in both scATAC and scRNA
ptbins=c(colnames(ph$scatac),colnames(ph$scrna))
ptbins=ptbins[duplicated(ptbins)];length(ptbins)
print(paste0("the number of bins are consistent between scRNA and scATAC: ",length(ptbins)))
avg.atac=ph$scatac[,ptbins]
avg.rna=ph$scrna[,ptbins]

log=TRUE
if(log){
    avg.atac=log2(avg.atac+1-min(avg.atac))
    avg.rna=log2(avg.rna+1)
}

scale=TRUE
if(scale){
    avg.atac=t(scale(t(avg.atac)))
    avg.rna=t(scale(t(avg.rna)))
}
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
##################
## rename motifs
# keep only motifs from the same origin
tfnames=mf2tfnames.all[[samples]]

# keep only motifs along chondrogenesis
tfnames=tfnames[tfnames$cls %in% ptime.clsid[[samples]] & tfnames$redundant=="N",]

# deal with "|"
tfnames$unique=paste0(tfnames$origin,"_",tfnames$tfname,"_",
                      sapply(strsplit(tfnames$motifid,"-"),"[",1),"_",
                      sapply(strsplit(tfnames$motifid,"-"),"[",2))
used.tfnew=tfnames
rownames(used.tfnew)=used.tfnew$unique
used.tfextra=NULL
for(i in 1:nrow(used.tfnew)){
  if(grepl("\\|",used.tfnew$tfname[i])){
    tmp.mf=gsub("\\|",",",used.tfnew$tfname[i])
    tmp.mf=unlist(strsplit(tmp.mf,","))
    tmp.extra=as.data.frame(lapply(tfnames[i,], rep, length(tmp.mf)))
    tmp.extra$tfname=tmp.mf
    used.tfextra=rbind(used.tfextra,tmp.extra)
  }
}
used.tfextra$unique=paste0(used.tfextra$origin,"_",used.tfextra$tfname,"_",
                      sapply(strsplit(used.tfextra$motifid,"-"),"[",1),"_",
                      sapply(strsplit(used.tfextra$motifid,"-"),"[",2))
#used.tfextra[duplicated(used.tfextra$tfname),]
used.tfnew=rbind(used.tfnew,used.tfextra)
used.tfnew=used.tfnew[!grepl("\\|",used.tfnew$tfname),];dim(used.tfnew)
used.tfnew=used.tfnew[!duplicated(used.tfnew$unique),]
dim(used.tfnew);dim(tfnames)
print(paste0("the number of motifs test (before deal with |): ",nrow(tfnames)))
print(paste0("the number of motifs test (after deal with |): ",nrow(used.tfnew)))

# rename motif based on that
tmp.atac=as.matrix(avg.atac[used.tfnew$motifid,])
rownames(tmp.atac)=used.tfnew$unique

##################
## rename genes

# may get NaN after scale
tmp.rna=avg.rna[!is.nan(rowSums(avg.rna)),]
tmp.rna=as.data.frame(tmp.rna)
tmp.rna$genename=gene.info[rownames(tmp.rna),"genename"]
tmp=tmp.rna[!duplicated(tmp.rna$genename) & !is.na(tmp.rna$genename),]
rownames(tmp)=tmp$genename;tmp=tmp[,1:(ncol(tmp.rna)-1)]
dim(tmp);dim(tmp.rna)
tmp.rna=as.matrix(tmp) 

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
##################
## test for each motif

#derived the result table from used.tfnew
res=used.tfnew[,c("tfname","motifid","unique",
                  "trend","defineClass","homerPval",
                  "cls","clsname","origin")]
res$originalTF=res$tfname
res$originalTF.pval=1;res$originalTF.padj=1;res$originalTF.cor=0
res$matchedTF=""
res$matchedTF.pval=1;res$matchedTF.padj=1;res$matchedTF.cor=0
res$chosenTF="";res$consist=0

for(i in 1:nrow(res)){
  # original TF
  tmp.atac.id=res$unique[i]
  tmp.rna.id=res$tfname[i]
  tmp.atac.value=as.numeric(tmp.atac[tmp.atac.id,])
  # in case rna do not have valid value after scale
  if(!(tmp.rna.id %in% rownames(tmp.rna))){
    tmp.rna.value=rep(0,length(tmp.atac.value))
  }else{
    tmp.rna.value=as.numeric(tmp.rna[tmp.rna.id,])
  }
  if(length(tmp.atac.value[!is.na(tmp.atac.value)])==0|length(tmp.rna.value[!is.na(tmp.rna.value)])==0){
    print(paste0("cannot compute for motif: ",tmp.atac.id,", ",tmp.rna.id))
    next
  }
  tmp.comput=cor.test(tmp.atac.value,tmp.rna.value,method="pearson")
  res$originalTF.pval[i]=tmp.comput$p.value
  res$originalTF.cor[i]=tmp.comput$estimate
  
  # paralogs
  tmp.atac.id=res$unique[i]
  tmp.rna.id=res$tfname[i]
  tmp.atac.value=as.numeric(tmp.atac[tmp.atac.id,])
  #if there are paralogs
  paralogs.tmp=paralogs[paralogs$Gene.name==tmp.rna.id,]
  print(paste0("the number of paralogs for ",tmp.rna.id," is: ",nrow(paralogs.tmp)))
  # the paralogs need to be TFs
  paralogs.tmp=paralogs.tmp[paralogs.tmp$Chicken.paralogue.gene.stable.ID %in% tf.set.id,]
  # the paralogs must have valid rna values
  paralogs.tmp=paralogs.tmp[toupper(paralogs.tmp$Chicken.paralogue.associated.gene.name) %in% rownames(tmp.rna),]
  print(paste0("the number of paralogs for ",tmp.rna.id,", that are TFs is: ",nrow(paralogs.tmp)))
  #sometimes there are wierd ones, i.e. "NPC2", which don't have paralogs, but still in the table
  if(nrow(paralogs.tmp)!=0 & paralogs.tmp$Chicken.paralogue.gene.stable.ID[1]!=""){
    res.tmp=data.frame(motif.TFs=tmp.rna.id,
                       gene.match=c(toupper(paralogs.tmp$Chicken.paralogue.associated.gene.name)),
                       pval=rep(1,(nrow(paralogs.tmp))),
                       cor=rep(0,(nrow(paralogs.tmp))))
    
    for(j in 1:nrow(res.tmp)){
      tmp.rnaAlt.value=as.numeric(tmp.rna[res.tmp$gene.match[j],])
      if(length(tmp.atac.value[!is.na(tmp.atac.value)])==0|length(tmp.rna.value[!is.na(tmp.rna.value)])==0){
        print(paste0("cannot compute for motif: ",tmp.atac.id,", ",res.tmp$gene.match[j]))
        next
      }
      comput.tmp=cor.test(tmp.atac.value,tmp.rnaAlt.value,method="pearson")
      res.tmp$pval[j]=comput.tmp$p.value
      res.tmp$cor[j]=comput.tmp$estimate
    }
    
    tmp.trend=res$trend[i]
    if(tmp.trend=="repressor"){
      res.one=res.tmp[order(res.tmp$cor),][1,]
    }else{
      res.one=res.tmp[order(-res.tmp$cor),][1,] #
    }
    
    res$matchedTF[i]=res.one$gene.match
    res$matchedTF.pval[i]=res.one$pval
    res$matchedTF.cor[i]=res.one$cor
    
  }else{
    # if no paralogs
    res$matchedTF[i]=res$originalTF[i]
    res$matchedTF.pval[i]=res$originalTF.pval[i]
    res$matchedTF.cor[i]=res$originalTF.cor[i]
  }
  
}

#multiple test
res$originalTF.padj=p.adjust(res$originalTF.pval,method="fdr",n=nrow(res))
res$matchedTF.padj=p.adjust(res$matchedTF.pval,method="fdr",n=nrow(res))

#remove NA value
res[is.na(res$originalTF.pval),"originalTF.pval"]=1
res[is.na(res$originalTF.padj),"originalTF.padj"]=1
res[is.na(res$originalTF.cor),"originalTF.cor"]=0
res[is.na(res$matchedTF.pval),"matchedTF.pval"]=1
res[is.na(res$matchedTF.padj),"matchedTF.padj"]=1
res[is.na(res$matchedTF.cor),"matchedTF.cor"]=0


```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
##################
## decide the chosen ones

res.ori=res
res=getChosenTF(res=res.ori)

length(unique(res$chosenTF))
table(res$trend)
table(res$consist)

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
# save
write.table(res,paste0("~/scATAC/motifReassign/ptbinCorrelation_",samples,".txt"),sep = "\t",quote = FALSE)

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
#####################
## deal with the reassigned motifs
# keep unique TF annotation per cluster (based on homerPval)
cls.uni=unique(res$cls)
res.keep=NULL

for(i in 1:length(cls.uni)){
  tmp.cls=cls.uni[i]
  tmp.res=res[res$cls==tmp.cls,]
  tmp.res=tmp.res[order(tmp.res$chosenTF,tmp.res$homerPval),]
  tmp.res=tmp.res[!duplicated(tmp.res$chosenTF),]
  res.keep=rbind(res.keep,tmp.res)
}
print(paste0("the number of motifs (before rm redundant TF annotation): ",nrow(res)))
print(paste0("the number of motifs (after rm redundant TF annotation): ",nrow(res.keep)))
table(res.keep$consist)

# put the res.keep in same format as mf2tfnames.all[[samples]]
res.keep$mfnew=paste0(res.keep$origin,"_",res.keep$chosenTF,"_",
                      sapply(strsplit(res.keep$motifid,"-"),"[",1),"_",
                      sapply(strsplit(res.keep$motifid,"-"),"[",2))
res.keep$redundant="N"
res.keep$tfFamily="unknown"
for(i in 1:nrow(res.keep)){
  tf=res.keep$chosenTF[i]
  tmp=tfs[tfs$Symbol==tf,"Family"]
  if(length(tmp)==0){
    next
  }else if(tmp==""){
    next
  }else{
    res.keep$tfFamily[i]=tmp
  }
};dim(res.keep[res.keep$tfFamily=="unknown",])

mf.keep=res.keep[,c("motifid","chosenTF","homerPval","defineClass",
                    "trend","mfnew","cls","tfFamily",
                    "clsname","redundant","origin","unique")]

#####################
## deal with the rest motifs
mf.rest=mf2tfnames.all[[samples]]
mf.rest=mf.rest[!(mf.rest$cls %in% ptime.clsid[[samples]]) & mf.rest$redundant=="N",]

dim(mf.rest[grepl("\\|",mf.rest$tfname),])
# deal with "|"
mf.rest$unique=paste0(mf.rest$origin,"_",mf.rest$tfname,"_",
                      sapply(strsplit(mf.rest$motifid,"-"),"[",1),"_",
                      sapply(strsplit(mf.rest$motifid,"-"),"[",2))
mf.rest$mfnew=mf.rest$unique
used.tfnew=mf.rest
rownames(used.tfnew)=used.tfnew$unique
used.tfextra=NULL
for(i in 1:nrow(used.tfnew)){
  if(grepl("\\|",used.tfnew$tfname[i])){
    tmp.mf=gsub("\\|",",",used.tfnew$tfname[i])
    tmp.mf=unlist(strsplit(tmp.mf,","))
    tmp.extra=as.data.frame(lapply(mf.rest[i,], rep, length(tmp.mf)))
    tmp.extra$tfname=tmp.mf
    used.tfextra=rbind(used.tfextra,tmp.extra)
  }
}
used.tfextra$unique=paste0(used.tfextra$origin,"_",used.tfextra$tfname,"_",
                           sapply(strsplit(used.tfextra$motifid,"-"),"[",1),"_",
                           sapply(strsplit(used.tfextra$motifid,"-"),"[",2))
#used.tfextra[duplicated(used.tfextra$tfname),]
used.tfnew=rbind(used.tfnew,used.tfextra)
used.tfnew=used.tfnew[!grepl("\\|",used.tfnew$tfname),];dim(used.tfnew)
used.tfnew=used.tfnew[!duplicated(used.tfnew$unique),]
dim(used.tfnew);dim(mf.rest)
print(paste0("the number of motifs test (before deal with |): ",nrow(mf.rest)))
print(paste0("the number of motifs test (after deal with |): ",nrow(used.tfnew)))
mf.rest=used.tfnew

# keep unique TF annotation per cluster (based on homerPval)
cls.uni=unique(mf.rest$cls)
mf.rest.keep=NULL
for(i in 1:length(cls.uni)){
  tmp.cls=cls.uni[i]
  tmp.mf.rest=mf.rest[mf.rest$cls==tmp.cls,]
  tmp.mf.rest=tmp.mf.rest[order(tmp.mf.rest$tfname,tmp.mf.rest$homerPval),]
  tmp.mf.rest=tmp.mf.rest[!duplicated(tmp.mf.rest$tfname),]
  mf.rest.keep=rbind(mf.rest.keep,tmp.mf.rest)
}
print(paste0("the number of motifs (before rm redundant TF annotation): ",nrow(mf.rest)))
print(paste0("the number of motifs (after rm redundant TF annotation): ",nrow(mf.rest.keep)))

#####################
## make a union with the rest clusters

print(colnames(mf.keep));print(colnames(mf.rest.keep))
colnames(mf.keep)=colnames(mf.rest.keep)
mf.union=rbind(mf.keep,mf.rest.keep);dim(mf.union)
mf.union$mfnew=paste0(mf.union$origin,"_",mf.union$tfname,"_",
                      sapply(strsplit(mf.union$motifid,"-"),"[",1),"_",
                      sapply(strsplit(mf.union$motifid,"-"),"[",2))
mf.union=mf.union[,!(colnames(mf.union) %in% c("unique"))]

write.table(mf.union,paste0("~/scATAC/motifReassign/motifUnion_",samples,".txt"),sep = "\t",quote = FALSE)

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
# use get2tf() to get the final set: 1 motif per TF
used.tf=get2tf(tfnames=mf.union,
               used.origin="L",used.cls="sub|Mschym",
               used.ptime=ptime.cls[[samples]])
dim(used.tf)
rownames(mf.union)=mf.union$mfnew
mf.remain=mf.union[used.tf$mfnew,];table(mf.remain$clsname)

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
mf.all=list()
mf.all[[samples]]=mf.remain
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}

```

## nasal

```{r, message=FALSE, warning=FALSE, echo=TRUE}
samples="nasal"
ph=readRDS(paste0("~/scATAC/motifReassign/ptbinMatrix_",samples,".rds"))
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
# keep only the ptbin in both scATAC and scRNA
ptbins=c(colnames(ph$scatac),colnames(ph$scrna))
ptbins=ptbins[duplicated(ptbins)];length(ptbins)
print(paste0("the number of bins are consistent between scRNA and scATAC: ",length(ptbins)))
avg.atac=ph$scatac[,ptbins]
avg.rna=ph$scrna[,ptbins]

log=TRUE
if(log){
    avg.atac=log2(avg.atac+1-min(avg.atac))
    avg.rna=log2(avg.rna+1)
}

scale=TRUE
if(scale){
    avg.atac=t(scale(t(avg.atac)))
    avg.rna=t(scale(t(avg.rna)))
}
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
##################
## rename motifs
# keep only motifs from the same origin
tfnames=mf2tfnames.all[[samples]]

# keep only motifs along chondrogenesis
tfnames=tfnames[tfnames$cls %in% ptime.clsid[[samples]] & tfnames$redundant=="N",]

# deal with "|"
tfnames$unique=paste0(tfnames$origin,"_",tfnames$tfname,"_",
                      sapply(strsplit(tfnames$motifid,"-"),"[",1),"_",
                      sapply(strsplit(tfnames$motifid,"-"),"[",2))
used.tfnew=tfnames
rownames(used.tfnew)=used.tfnew$unique
used.tfextra=NULL
for(i in 1:nrow(used.tfnew)){
  if(grepl("\\|",used.tfnew$tfname[i])){
    tmp.mf=gsub("\\|",",",used.tfnew$tfname[i])
    tmp.mf=unlist(strsplit(tmp.mf,","))
    tmp.extra=as.data.frame(lapply(tfnames[i,], rep, length(tmp.mf)))
    tmp.extra$tfname=tmp.mf
    used.tfextra=rbind(used.tfextra,tmp.extra)
  }
}
used.tfextra$unique=paste0(used.tfextra$origin,"_",used.tfextra$tfname,"_",
                      sapply(strsplit(used.tfextra$motifid,"-"),"[",1),"_",
                      sapply(strsplit(used.tfextra$motifid,"-"),"[",2))
#used.tfextra[duplicated(used.tfextra$tfname),]
used.tfnew=rbind(used.tfnew,used.tfextra)
used.tfnew=used.tfnew[!grepl("\\|",used.tfnew$tfname),];dim(used.tfnew)
used.tfnew=used.tfnew[!duplicated(used.tfnew$unique),]
dim(used.tfnew);dim(tfnames)
print(paste0("the number of motifs test (before deal with |): ",nrow(tfnames)))
print(paste0("the number of motifs test (after deal with |): ",nrow(used.tfnew)))

# rename motif based on that
tmp.atac=as.matrix(avg.atac[used.tfnew$motifid,])
rownames(tmp.atac)=used.tfnew$unique

##################
## rename genes

# may get NaN after scale
tmp.rna=avg.rna[!is.nan(rowSums(avg.rna)),]
tmp.rna=as.data.frame(tmp.rna)
tmp.rna$genename=gene.info[rownames(tmp.rna),"genename"]
tmp=tmp.rna[!duplicated(tmp.rna$genename) & !is.na(tmp.rna$genename),]
rownames(tmp)=tmp$genename;tmp=tmp[,1:(ncol(tmp.rna)-1)]
dim(tmp);dim(tmp.rna)
tmp.rna=as.matrix(tmp) 

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
##################
## test for each motif

#derived the result table from used.tfnew
res=used.tfnew[,c("tfname","motifid","unique",
                  "trend","defineClass","homerPval",
                  "cls","clsname","origin")]
res$originalTF=res$tfname
res$originalTF.pval=1;res$originalTF.padj=1;res$originalTF.cor=0
res$matchedTF=""
res$matchedTF.pval=1;res$matchedTF.padj=1;res$matchedTF.cor=0
res$chosenTF="";res$consist=0

for(i in 1:nrow(res)){
  # original TF
  tmp.atac.id=res$unique[i]
  tmp.rna.id=res$tfname[i]
  tmp.atac.value=as.numeric(tmp.atac[tmp.atac.id,])
  # in case rna do not have valid value after scale
  if(!(tmp.rna.id %in% rownames(tmp.rna))){
    tmp.rna.value=rep(0,length(tmp.atac.value))
  }else{
    tmp.rna.value=as.numeric(tmp.rna[tmp.rna.id,])
  }
  if(length(tmp.atac.value[!is.na(tmp.atac.value)])==0|length(tmp.rna.value[!is.na(tmp.rna.value)])==0){
    print(paste0("cannot compute for motif: ",tmp.atac.id,", ",tmp.rna.id))
    next
  }
  tmp.comput=cor.test(tmp.atac.value,tmp.rna.value,method="pearson")
  res$originalTF.pval[i]=tmp.comput$p.value
  res$originalTF.cor[i]=tmp.comput$estimate
  
  # paralogs
  tmp.atac.id=res$unique[i]
  tmp.rna.id=res$tfname[i]
  tmp.atac.value=as.numeric(tmp.atac[tmp.atac.id,])
  #if there are paralogs
  paralogs.tmp=paralogs[paralogs$Gene.name==tmp.rna.id,]
  print(paste0("the number of paralogs for ",tmp.rna.id," is: ",nrow(paralogs.tmp)))
  # the paralogs need to be TFs
  paralogs.tmp=paralogs.tmp[paralogs.tmp$Chicken.paralogue.gene.stable.ID %in% tf.set.id,]
  # the paralogs must have valid rna values
  paralogs.tmp=paralogs.tmp[toupper(paralogs.tmp$Chicken.paralogue.associated.gene.name) %in% rownames(tmp.rna),]
  print(paste0("the number of paralogs for ",tmp.rna.id,", that are TFs is: ",nrow(paralogs.tmp)))
  #sometimes there are wierd ones, i.e. "NPC2", which don't have paralogs, but still in the table
  if(nrow(paralogs.tmp)!=0 & paralogs.tmp$Chicken.paralogue.gene.stable.ID[1]!=""){
    res.tmp=data.frame(motif.TFs=tmp.rna.id,
                       gene.match=c(toupper(paralogs.tmp$Chicken.paralogue.associated.gene.name)),
                       pval=rep(1,(nrow(paralogs.tmp))),
                       cor=rep(0,(nrow(paralogs.tmp))))
    
    for(j in 1:nrow(res.tmp)){
      tmp.rnaAlt.value=as.numeric(tmp.rna[res.tmp$gene.match[j],])
      if(length(tmp.atac.value[!is.na(tmp.atac.value)])==0|length(tmp.rna.value[!is.na(tmp.rna.value)])==0){
        print(paste0("cannot compute for motif: ",tmp.atac.id,", ",res.tmp$gene.match[j]))
        next
      }
      comput.tmp=cor.test(tmp.atac.value,tmp.rnaAlt.value,method="pearson")
      res.tmp$pval[j]=comput.tmp$p.value
      res.tmp$cor[j]=comput.tmp$estimate
    }
    
    tmp.trend=res$trend[i]
    if(tmp.trend=="repressor"){
      res.one=res.tmp[order(res.tmp$cor),][1,]
    }else{
      res.one=res.tmp[order(-res.tmp$cor),][1,] #
    }
    
    res$matchedTF[i]=res.one$gene.match
    res$matchedTF.pval[i]=res.one$pval
    res$matchedTF.cor[i]=res.one$cor
    
  }else{
    # if no paralogs
    res$matchedTF[i]=res$originalTF[i]
    res$matchedTF.pval[i]=res$originalTF.pval[i]
    res$matchedTF.cor[i]=res$originalTF.cor[i]
  }
  
}

#multiple test
res$originalTF.padj=p.adjust(res$originalTF.pval,method="fdr",n=nrow(res))
res$matchedTF.padj=p.adjust(res$matchedTF.pval,method="fdr",n=nrow(res))

#remove NA value
res[is.na(res$originalTF.pval),"originalTF.pval"]=1
res[is.na(res$originalTF.padj),"originalTF.padj"]=1
res[is.na(res$originalTF.cor),"originalTF.cor"]=0
res[is.na(res$matchedTF.pval),"matchedTF.pval"]=1
res[is.na(res$matchedTF.padj),"matchedTF.padj"]=1
res[is.na(res$matchedTF.cor),"matchedTF.cor"]=0


```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
##################
## decide the chosen ones

res.ori=res
res=getChosenTF(res=res.ori)

length(unique(res$chosenTF))
table(res$trend)
table(res$consist)

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
# save
write.table(res,paste0("~/scATAC/motifReassign/ptbinCorrelation_",samples,".txt"),sep = "\t",quote = FALSE)

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
#####################
## deal with the reassigned motifs
# keep unique TF annotation per cluster (based on homerPval)
cls.uni=unique(res$cls)
res.keep=NULL

for(i in 1:length(cls.uni)){
  tmp.cls=cls.uni[i]
  tmp.res=res[res$cls==tmp.cls,]
  tmp.res=tmp.res[order(tmp.res$chosenTF,tmp.res$homerPval),]
  tmp.res=tmp.res[!duplicated(tmp.res$chosenTF),]
  res.keep=rbind(res.keep,tmp.res)
}
print(paste0("the number of motifs (before rm redundant TF annotation): ",nrow(res)))
print(paste0("the number of motifs (after rm redundant TF annotation): ",nrow(res.keep)))
table(res.keep$consist)

# put the res.keep in same format as mf2tfnames.all[[samples]]
res.keep$mfnew=paste0(res.keep$origin,"_",res.keep$chosenTF,"_",
                      sapply(strsplit(res.keep$motifid,"-"),"[",1),"_",
                      sapply(strsplit(res.keep$motifid,"-"),"[",2))
res.keep$redundant="N"
res.keep$tfFamily="unknown"
for(i in 1:nrow(res.keep)){
  tf=res.keep$chosenTF[i]
  tmp=tfs[tfs$Symbol==tf,"Family"]
  if(length(tmp)==0){
    next
  }else if(tmp==""){
    next
  }else{
    res.keep$tfFamily[i]=tmp
  }
};dim(res.keep[res.keep$tfFamily=="unknown",])

mf.keep=res.keep[,c("motifid","chosenTF","homerPval","defineClass",
                    "trend","mfnew","cls","tfFamily",
                    "clsname","redundant","origin","unique")]

#####################
## deal with the rest motifs
mf.rest=mf2tfnames.all[[samples]]
mf.rest=mf.rest[!(mf.rest$cls %in% ptime.clsid[[samples]]) & mf.rest$redundant=="N",]

dim(mf.rest[grepl("\\|",mf.rest$tfname),])
# deal with "|"
mf.rest$unique=paste0(mf.rest$origin,"_",mf.rest$tfname,"_",
                      sapply(strsplit(mf.rest$motifid,"-"),"[",1),"_",
                      sapply(strsplit(mf.rest$motifid,"-"),"[",2))
mf.rest$mfnew=mf.rest$unique
used.tfnew=mf.rest
rownames(used.tfnew)=used.tfnew$unique
used.tfextra=NULL
for(i in 1:nrow(used.tfnew)){
  if(grepl("\\|",used.tfnew$tfname[i])){
    tmp.mf=gsub("\\|",",",used.tfnew$tfname[i])
    tmp.mf=unlist(strsplit(tmp.mf,","))
    tmp.extra=as.data.frame(lapply(mf.rest[i,], rep, length(tmp.mf)))
    tmp.extra$tfname=tmp.mf
    used.tfextra=rbind(used.tfextra,tmp.extra)
  }
}
used.tfextra$unique=paste0(used.tfextra$origin,"_",used.tfextra$tfname,"_",
                           sapply(strsplit(used.tfextra$motifid,"-"),"[",1),"_",
                           sapply(strsplit(used.tfextra$motifid,"-"),"[",2))
#used.tfextra[duplicated(used.tfextra$tfname),]
used.tfnew=rbind(used.tfnew,used.tfextra)
used.tfnew=used.tfnew[!grepl("\\|",used.tfnew$tfname),];dim(used.tfnew)
used.tfnew=used.tfnew[!duplicated(used.tfnew$unique),]
dim(used.tfnew);dim(mf.rest)
print(paste0("the number of motifs test (before deal with |): ",nrow(mf.rest)))
print(paste0("the number of motifs test (after deal with |): ",nrow(used.tfnew)))
mf.rest=used.tfnew

# keep unique TF annotation per cluster (based on homerPval)
cls.uni=unique(mf.rest$cls)
mf.rest.keep=NULL
for(i in 1:length(cls.uni)){
  tmp.cls=cls.uni[i]
  tmp.mf.rest=mf.rest[mf.rest$cls==tmp.cls,]
  tmp.mf.rest=tmp.mf.rest[order(tmp.mf.rest$tfname,tmp.mf.rest$homerPval),]
  tmp.mf.rest=tmp.mf.rest[!duplicated(tmp.mf.rest$tfname),]
  mf.rest.keep=rbind(mf.rest.keep,tmp.mf.rest)
}
print(paste0("the number of motifs (before rm redundant TF annotation): ",nrow(mf.rest)))
print(paste0("the number of motifs (after rm redundant TF annotation): ",nrow(mf.rest.keep)))

#####################
## make a union with the rest clusters

colnames(mf.keep)=colnames(mf.rest.keep)
mf.union=rbind(mf.keep,mf.rest.keep);dim(mf.union)
mf.union$mfnew=paste0(mf.union$origin,"_",mf.union$tfname,"_",
                      sapply(strsplit(mf.union$motifid,"-"),"[",1),"_",
                      sapply(strsplit(mf.union$motifid,"-"),"[",2))
mf.union=mf.union[,!(colnames(mf.union) %in% c("unique"))]

write.table(mf.union,paste0("~/scATAC/motifReassign/motifUnion_",samples,".txt"),sep = "\t",quote = FALSE)

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
# use get2tf() to get the final set: 1 motif per TF
used.tf=get2tf(tfnames=mf.union,
               used.origin="N",used.cls="sub|Mschym",
               used.ptime=ptime.cls[[samples]])
dim(used.tf)
rownames(mf.union)=mf.union$mfnew
mf.remain=mf.union[used.tf$mfnew,];table(mf.remain$clsname)

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
mf.all[[samples]]=mf.remain
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}

```

## somite

```{r, message=FALSE, warning=FALSE, echo=TRUE}
samples="somite"
ph=readRDS(paste0("~/scATAC/motifReassign/ptbinMatrix_",samples,".rds"))
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
# keep only the ptbin in both scATAC and scRNA
ptbins=c(colnames(ph$scatac),colnames(ph$scrna))
ptbins=ptbins[duplicated(ptbins)];length(ptbins)
print(paste0("the number of bins are consistent between scRNA and scATAC: ",length(ptbins)))
avg.atac=ph$scatac[,ptbins]
avg.rna=ph$scrna[,ptbins]

log=TRUE
if(log){
    avg.atac=log2(avg.atac+1-min(avg.atac))
    avg.rna=log2(avg.rna+1)
}

scale=TRUE
if(scale){
    avg.atac=t(scale(t(avg.atac)))
    avg.rna=t(scale(t(avg.rna)))
}
```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
##################
## rename motifs
# keep only motifs from the same origin
tfnames=mf2tfnames.all[[samples]]

# keep only motifs along chondrogenesis
tfnames=tfnames[tfnames$cls %in% ptime.clsid[[samples]] & tfnames$redundant=="N",]

# deal with "|"
tfnames$unique=paste0(tfnames$origin,"_",tfnames$tfname,"_",
                      sapply(strsplit(tfnames$motifid,"-"),"[",1),"_",
                      sapply(strsplit(tfnames$motifid,"-"),"[",2))
used.tfnew=tfnames
rownames(used.tfnew)=used.tfnew$unique
used.tfextra=NULL
for(i in 1:nrow(used.tfnew)){
  if(grepl("\\|",used.tfnew$tfname[i])){
    tmp.mf=gsub("\\|",",",used.tfnew$tfname[i])
    tmp.mf=unlist(strsplit(tmp.mf,","))
    tmp.extra=as.data.frame(lapply(tfnames[i,], rep, length(tmp.mf)))
    tmp.extra$tfname=tmp.mf
    used.tfextra=rbind(used.tfextra,tmp.extra)
  }
}
used.tfextra$unique=paste0(used.tfextra$origin,"_",used.tfextra$tfname,"_",
                      sapply(strsplit(used.tfextra$motifid,"-"),"[",1),"_",
                      sapply(strsplit(used.tfextra$motifid,"-"),"[",2))
#used.tfextra[duplicated(used.tfextra$tfname),]
used.tfnew=rbind(used.tfnew,used.tfextra)
used.tfnew=used.tfnew[!grepl("\\|",used.tfnew$tfname),];dim(used.tfnew)
used.tfnew=used.tfnew[!duplicated(used.tfnew$unique),]
dim(used.tfnew);dim(tfnames)
print(paste0("the number of motifs test (before deal with |): ",nrow(tfnames)))
print(paste0("the number of motifs test (after deal with |): ",nrow(used.tfnew)))

# rename motif based on that
tmp.atac=as.matrix(avg.atac[used.tfnew$motifid,])
rownames(tmp.atac)=used.tfnew$unique

##################
## rename genes

# may get NaN after scale
tmp.rna=avg.rna[!is.nan(rowSums(avg.rna)),]
tmp.rna=as.data.frame(tmp.rna)
tmp.rna$genename=gene.info[rownames(tmp.rna),"genename"]
tmp=tmp.rna[!duplicated(tmp.rna$genename) & !is.na(tmp.rna$genename),]
rownames(tmp)=tmp$genename;tmp=tmp[,1:(ncol(tmp.rna)-1)]
dim(tmp);dim(tmp.rna)
tmp.rna=as.matrix(tmp) 

```


```{r, message=FALSE, warning=FALSE, echo=TRUE}
##################
## test for each motif

#derived the result table from used.tfnew
res=used.tfnew[,c("tfname","motifid","unique",
                  "trend","defineClass","homerPval",
                  "cls","clsname","origin")]
res$originalTF=res$tfname
res$originalTF.pval=1;res$originalTF.padj=1;res$originalTF.cor=0
res$matchedTF=""
res$matchedTF.pval=1;res$matchedTF.padj=1;res$matchedTF.cor=0
res$chosenTF="";res$consist=0

for(i in 1:nrow(res)){
  # original TF
  tmp.atac.id=res$unique[i]
  tmp.rna.id=res$tfname[i]
  tmp.atac.value=as.numeric(tmp.atac[tmp.atac.id,])
  # in case rna do not have valid value after scale
  if(!(tmp.rna.id %in% rownames(tmp.rna))){
    tmp.rna.value=rep(0,length(tmp.atac.value))
  }else{
    tmp.rna.value=as.numeric(tmp.rna[tmp.rna.id,])
  }
  if(length(tmp.atac.value[!is.na(tmp.atac.value)])==0|length(tmp.rna.value[!is.na(tmp.rna.value)])==0){
    print(paste0("cannot compute for motif: ",tmp.atac.id,", ",tmp.rna.id))
    next
  }
  tmp.comput=cor.test(tmp.atac.value,tmp.rna.value,method="pearson")
  res$originalTF.pval[i]=tmp.comput$p.value
  res$originalTF.cor[i]=tmp.comput$estimate
  
  # paralogs
  tmp.atac.id=res$unique[i]
  tmp.rna.id=res$tfname[i]
  tmp.atac.value=as.numeric(tmp.atac[tmp.atac.id,])
  #if there are paralogs
  paralogs.tmp=paralogs[paralogs$Gene.name==tmp.rna.id,]
  print(paste0("the number of paralogs for ",tmp.rna.id," is: ",nrow(paralogs.tmp)))
  # the paralogs need to be TFs
  paralogs.tmp=paralogs.tmp[paralogs.tmp$Chicken.paralogue.gene.stable.ID %in% tf.set.id,]
  # the paralogs must have valid rna values
  paralogs.tmp=paralogs.tmp[toupper(paralogs.tmp$Chicken.paralogue.associated.gene.name) %in% rownames(tmp.rna),]
  print(paste0("the number of paralogs for ",tmp.rna.id,", that are TFs is: ",nrow(paralogs.tmp)))
  #sometimes there are wierd ones, i.e. "NPC2", which don't have paralogs, but still in the table
  if(nrow(paralogs.tmp)!=0 & paralogs.tmp$Chicken.paralogue.gene.stable.ID[1]!=""){
    res.tmp=data.frame(motif.TFs=tmp.rna.id,
                       gene.match=c(toupper(paralogs.tmp$Chicken.paralogue.associated.gene.name)),
                       pval=rep(1,(nrow(paralogs.tmp))),
                       cor=rep(0,(nrow(paralogs.tmp))))
    
    for(j in 1:nrow(res.tmp)){
      tmp.rnaAlt.value=as.numeric(tmp.rna[res.tmp$gene.match[j],])
      if(length(tmp.atac.value[!is.na(tmp.atac.value)])==0|length(tmp.rna.value[!is.na(tmp.rna.value)])==0){
        print(paste0("cannot compute for motif: ",tmp.atac.id,", ",res.tmp$gene.match[j]))
        next
      }
      comput.tmp=cor.test(tmp.atac.value,tmp.rnaAlt.value,method="pearson")
      res.tmp$pval[j]=comput.tmp$p.value
      res.tmp$cor[j]=comput.tmp$estimate
    }
    
    tmp.trend=res$trend[i]
    if(tmp.trend=="repressor"){
      res.one=res.tmp[order(res.tmp$cor),][1,]
    }else{
      res.one=res.tmp[order(-res.tmp$cor),][1,] #
    }
    
    res$matchedTF[i]=res.one$gene.match
    res$matchedTF.pval[i]=res.one$pval
    res$matchedTF.cor[i]=res.one$cor
    
  }else{
    # if no paralogs
    res$matchedTF[i]=res$originalTF[i]
    res$matchedTF.pval[i]=res$originalTF.pval[i]
    res$matchedTF.cor[i]=res$originalTF.cor[i]
  }
  
}

#multiple test
res$originalTF.padj=p.adjust(res$originalTF.pval,method="fdr",n=nrow(res))
res$matchedTF.padj=p.adjust(res$matchedTF.pval,method="fdr",n=nrow(res))

#remove NA value
res[is.na(res$originalTF.pval),"originalTF.pval"]=1
res[is.na(res$originalTF.padj),"originalTF.padj"]=1
res[is.na(res$originalTF.cor),"originalTF.cor"]=0
res[is.na(res$matchedTF.pval),"matchedTF.pval"]=1
res[is.na(res$matchedTF.padj),"matchedTF.padj"]=1
res[is.na(res$matchedTF.cor),"matchedTF.cor"]=0


```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
##################
## decide the chosen ones

res.ori=res
res=getChosenTF(res=res.ori)

length(unique(res$chosenTF))
table(res$trend)
table(res$consist)

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
# save
write.table(res,paste0("~/scATAC/motifReassign/ptbinCorrelation_",samples,".txt"),sep = "\t",quote = FALSE)

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
#####################
## deal with the reassigned motifs
# keep unique TF annotation per cluster (based on homerPval)
cls.uni=unique(res$cls)
res.keep=NULL

for(i in 1:length(cls.uni)){
  tmp.cls=cls.uni[i]
  tmp.res=res[res$cls==tmp.cls,]
  tmp.res=tmp.res[order(tmp.res$chosenTF,tmp.res$homerPval),]
  tmp.res=tmp.res[!duplicated(tmp.res$chosenTF),]
  res.keep=rbind(res.keep,tmp.res)
}
print(paste0("the number of motifs (before rm redundant TF annotation): ",nrow(res)))
print(paste0("the number of motifs (after rm redundant TF annotation): ",nrow(res.keep)))
table(res.keep$consist)

# put the res.keep in same format as mf2tfnames.all[[samples]]
res.keep$mfnew=paste0(res.keep$origin,"_",res.keep$chosenTF,"_",
                      sapply(strsplit(res.keep$motifid,"-"),"[",1),"_",
                      sapply(strsplit(res.keep$motifid,"-"),"[",2))
res.keep$redundant="N"
res.keep$tfFamily="unknown"
for(i in 1:nrow(res.keep)){
  tf=res.keep$chosenTF[i]
  tmp=tfs[tfs$Symbol==tf,"Family"]
  if(length(tmp)==0){
    next
  }else if(tmp==""){
    next
  }else{
    res.keep$tfFamily[i]=tmp
  }
};dim(res.keep[res.keep$tfFamily=="unknown",])

mf.keep=res.keep[,c("motifid","chosenTF","homerPval","defineClass",
                    "trend","mfnew","cls","tfFamily",
                    "clsname","redundant","origin","unique")]

#####################
## deal with the rest motifs
mf.rest=mf2tfnames.all[[samples]]
mf.rest=mf.rest[!(mf.rest$cls %in% ptime.clsid[[samples]]) & mf.rest$redundant=="N",]

dim(mf.rest[grepl("\\|",mf.rest$tfname),])
# deal with "|"
mf.rest$unique=paste0(mf.rest$origin,"_",mf.rest$tfname,"_",
                      sapply(strsplit(mf.rest$motifid,"-"),"[",1),"_",
                      sapply(strsplit(mf.rest$motifid,"-"),"[",2))
mf.rest$mfnew=mf.rest$unique
used.tfnew=mf.rest
rownames(used.tfnew)=used.tfnew$unique
used.tfextra=NULL
for(i in 1:nrow(used.tfnew)){
  if(grepl("\\|",used.tfnew$tfname[i])){
    tmp.mf=gsub("\\|",",",used.tfnew$tfname[i])
    tmp.mf=unlist(strsplit(tmp.mf,","))
    tmp.extra=as.data.frame(lapply(mf.rest[i,], rep, length(tmp.mf)))
    tmp.extra$tfname=tmp.mf
    used.tfextra=rbind(used.tfextra,tmp.extra)
  }
}
used.tfextra$unique=paste0(used.tfextra$origin,"_",used.tfextra$tfname,"_",
                           sapply(strsplit(used.tfextra$motifid,"-"),"[",1),"_",
                           sapply(strsplit(used.tfextra$motifid,"-"),"[",2))
#used.tfextra[duplicated(used.tfextra$tfname),]
used.tfnew=rbind(used.tfnew,used.tfextra)
used.tfnew=used.tfnew[!grepl("\\|",used.tfnew$tfname),];dim(used.tfnew)
used.tfnew=used.tfnew[!duplicated(used.tfnew$unique),]
dim(used.tfnew);dim(mf.rest)
print(paste0("the number of motifs test (before deal with |): ",nrow(mf.rest)))
print(paste0("the number of motifs test (after deal with |): ",nrow(used.tfnew)))
mf.rest=used.tfnew

# keep unique TF annotation per cluster (based on homerPval)
cls.uni=unique(mf.rest$cls)
mf.rest.keep=NULL
for(i in 1:length(cls.uni)){
  tmp.cls=cls.uni[i]
  tmp.mf.rest=mf.rest[mf.rest$cls==tmp.cls,]
  tmp.mf.rest=tmp.mf.rest[order(tmp.mf.rest$tfname,tmp.mf.rest$homerPval),]
  tmp.mf.rest=tmp.mf.rest[!duplicated(tmp.mf.rest$tfname),]
  mf.rest.keep=rbind(mf.rest.keep,tmp.mf.rest)
}
print(paste0("the number of motifs (before rm redundant TF annotation): ",nrow(mf.rest)))
print(paste0("the number of motifs (after rm redundant TF annotation): ",nrow(mf.rest.keep)))

#####################
## make a union with the rest clusters

colnames(mf.keep)=colnames(mf.rest.keep)
mf.union=rbind(mf.keep,mf.rest.keep);dim(mf.union)
mf.union$mfnew=paste0(mf.union$origin,"_",mf.union$tfname,"_",
                      sapply(strsplit(mf.union$motifid,"-"),"[",1),"_",
                      sapply(strsplit(mf.union$motifid,"-"),"[",2))
mf.union=mf.union[,!(colnames(mf.union) %in% c("unique"))]

write.table(mf.union,paste0("~/scATAC/motifReassign/motifUnion_",samples,".txt"),sep = "\t",quote = FALSE)

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
# use get2tf() to get the final set: 1 motif per TF
used.tf=get2tf(tfnames=mf.union,
               used.origin="S",used.cls="sub|Mschym",
               used.ptime=ptime.cls[[samples]])
dim(used.tf)
rownames(mf.union)=mf.union$mfnew
mf.remain=mf.union[used.tf$mfnew,];table(mf.remain$clsname)

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
mf.all[[samples]]=mf.remain
```

## save

```{r, message=FALSE, warning=FALSE, echo=TRUE}
saveRDS(mf.all,"~/scATAC/motifReassign/motifUnion_originConsist.rds")
```

## log

```{r, message=FALSE, warning=FALSE, echo=TRUE}

```

```{r, message=FALSE, warning=FALSE, echo=TRUE}
sessionInfo()
```
